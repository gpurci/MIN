        def load_items_csv(self, filepath):
            """
            Citeste fisierul ITEMS_SELECTION.csv si populeaza self.items
            """
            df = pd.read_csv(filepath, sep="\t", header=0)

            items = []
            for i in range(len(df)):
                row = df.iloc[i]

                city  = int(row["ASSIGNED_NODE_NUMBER"])
                w     = float(row["WEIGHT"])
                p     = float(row["PROFIT"])

                items.append((city, w, p))

            self.items = items

        # functia fitness cu decadere liniara
        def fitness_ttp_linear(self, population):
            """
            Fitness cu decadere liniara.
            Pentru fiecare individ:
            - mergem pe traseu (route)
            - cand ajungem intr-un oras luam obiectele de acolo
            - profitul scade liniar cu timpul:
                    p(t) = p0 - alpha * t
            - viteza scade in functie de greutatea acumulata
            - costul de timp este penalizat cu R
            Returneaza:
                vector np.array cu fitness pentru fiecare individ
            """
            fitness_values = np.zeros(population.shape[0], dtype=float)

            for idx, individ in enumerate(population):

                current_weight = 0.0
                total_profit   = 0.0
                total_time     = 0.0

                # parcurgem route oras cu oras
                for i in range(len(individ)-1):
                    city = individ[i]

                    # luam itemele din acest oras
                    for (city_k, weight_k, profit_k) in self.items:
                        if city_k == city:
                            # profit linear: p0 - alpha * t
                            p = profit_k - self.alpha*total_time
                            if p < 0.0:
                                p = 0.0
                            total_profit   += p
                            current_weight += weight_k

                    # viteza in functie de greutate
                    v = self.v_max - (self.v_max - self.v_min)*(current_weight / self.W)

                    # timp = distanta / viteza
                    total_time += self.distance[individ[i], individ[i+1]] / v

                # inchidere ciclu inapoi la orasul de start
                v = self.v_max - (self.v_max - self.v_min)*(current_weight / self.W)
                total_time += self.distance[individ[-1], individ[0]] / v

                fitness_values[idx] = total_profit - self.R * total_time

            return fitness_values


        # functia fitness cu decadere exponentiala
        def fitness_ttp_exp(self, population):
            """
            - pe măsură ce vizităm oraşele, luăm obiectele găsite acolo
            - fiecare obiect are profitul iniţial p0
            - dar profitul scade cu timpul deoarece obiectul este „mai puţin valoros” dacă ajungi târziu
            - decădere exponenţială:
                p(t) = p0 * exp(- λ * timp)
            - viteza berlinei scade pe măsură ce rucsacul se încarcă cu obiecte
                v = v_max - (v_max - v_min) * (greutate_curentă / W)

            Returneaza
                fitness = profit_total - R * timp_total
            """
            fitness_values = np.zeros(population.shape[0], dtype=float)

            for idx, individ in enumerate(population):

                current_weight = 0.0
                total_profit   = 0.0
                total_time     = 0.0

                # mergem prin route
                for i in range(len(individ)-1):
                    city = individ[i]

                    # luam obiectele din acest oras
                    for (city_k, weight_k, profit_k) in self.items:
                        if city_k == city:
                            # profit exponential
                            p = profit_k * np.exp(-self.lam * total_time)
                            total_profit   += p
                            current_weight += weight_k

                    # viteza in functie de greutate
                    v = self.v_max - (self.v_max - self.v_min)*(current_weight / self.W)

                    # timp = distanta / viteza
                    total_time += self.distance[individ[i], individ[i+1]] / v

                # inchidere ciclu inapoi la orasul de start
                v = self.v_max - (self.v_max - self.v_min)*(current_weight / self.W)
                total_time += self.distance[individ[-1], individ[0]] / v

                fitness_values[idx] = total_profit - self.R * total_time

            return fitness_values